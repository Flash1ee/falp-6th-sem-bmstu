\section*{Задание 1}
\subsection*{Постановка задачи}

Написать функцию, которая принимает целое число и возвращает первое четное число, не меньшее аргумента.  

\begin{lstlisting}[label=4xd,caption=Решение задания №1, language=lisp]

\end{lstlisting}

\subsection*{Решение}
%\lstinputlisting[language=lisp]{../src/1.lsp}

\section*{Задание 2}
\subsection*{Постановка задачи}

Написать функцию, которая принимает число и возвращает число того же знака, но с модулем на 1 больше модуля аргумента.

\subsection*{Решение}
%\lstinputlisting[language=lisp]{../src/2.lsp}


\section*{Задание 3}
\subsection*{Условие задачи}
Написать функцию, которая принимает два числа и возвращает список из этих чисел, расположенный по возрастанию.

\subsection*{Решение}
%\lstinputlisting[language=lisp]{../src/3.lsp}

\section*{Задание 4}
\subsection*{Условие задачи}
Написать функцию, которая принимает три числа и возвращает Т только тогда, когда первое число расположено между вторым и третьим.

\subsection*{Решение}



\section*{Задание 5}
\subsection*{Условие задачи}
Каков результат вычисления следующих выражений?

\subsection*{Решение}

\begin{lstlisting}[label=5xd,caption=Решение задания №5, language=lisp]
  (and 'fee 'fie 'foe)            ; FOE
  (or 'fee 'fie 'foe)             ; FEE
  (and (equal 'abc 'abc) 'yes)    ; YES
  (or nil 'fie 'foe)              ; FIE
  (and nil 'fie 'foe)             ; NIL
  (or (equal 'abc 'abc) 'yes)     ; T
\end{lstlisting}

\section*{Задание 6}
\subsection*{Условие задачи}
Написать предикат, который принимает два числа-аргумента и возвращает Т, если первое число не меньше второго.

\subsection*{Решение}

\begin{lstlisting}[label=6xd,caption=Решение задания №6, language=lisp]
(cons 3 (list 5 6)) -> (356)
(cons 3 `(list 5 6)) -> (3 LIST 5 6)
(list 3 'from 9 'lives (- 9 3)) -> 3 FROM 9 LIVES 6
(+ (length for 2 too)) (car '(21 22 23))) -> error
(cdr `(cons is short for ans)) -> (IS SHORT FOR ANS)
(car (list one two)); VARIABLE ONE IS UNBOUND; (car (list `one `two)); -> ONE
(car (list `one `two)) -> ONE
\end{lstlisting}

\section*{Задание 7}
\subsection*{Условие задачи}
Какой из следующих двух вариантов предиката ошибочен и почему?

\subsection*{Решение}

\begin{lstlisting}[label=7xd,caption=Решение задания №7, language=lisp]
(defun pred1 (x)
  (and (numberp x) (plusp x)))    ; Ok

(defun pred2 (x)
  (and (plusp x) (numberp x)))    ; Not Ok 
\end{lstlisting}

\section*{Задание 8}
\subsection*{Условие задачи}
Решить задачу 4, используя для ее решения конструкции IF, COND, AND/OR.


\subsection*{Решение}
%\lstinputlisting[label=7xd,caption=Решение задания №8, language=lisp]{../src/8.lsp}

\section*{Задание 9}
\subsection*{Условие задачи}
Переписать функцию how-alike, приведенную в лекции и использующую COND, используя только конструкции IF, AND/OR.

\subsection*{Решение}
\begin{lstlisting}[label=7xd,caption=Решение задания №9, language=lisp]
(list 'cons t NIL); (CONS T NIL)
(eval (list 'cons t NIL)) ; (T)
(eval (eval (list 'cons t NIL))) error
(apply #cons "(t NIL)) 
(eval NIL)
(list 'eval NIL) 
(eval (list 'eval NIL))
\end{lstlisting}

\section*{Контрольные вопросы}

\subsection*{1.Базис языка {\texttt{Lisp}}}

Базис языка представлен:
\begin{itemize}
	\item структурами, атомами;
	\item функциями:\\
	{\texttt{atom, eq, cons, car, cdr,}}\\
	{\texttt{cond, quote, lambda, eval, label}}.
\end{itemize}

\subsection*{2. Классификация функций языка {\texttt{Lisp}}}

Функции в языке {\texttt{Lisp}}:
\begin{itemize}
	\item чистые (с фиксированным количеством аргументов) -- математические функции;
	\item рекурсивные функции;
	\item специальные функции -- формы (принимают произвольное количество аргументов или по разному обрабатывают аргументы);
	\item псевдофункции (создающие <<эффект>> - отображающие на экране процесс обработки данных и т. п.);
	\item функции с вариативными значениями, выбирающие одно значение;
	\item функции высших порядков -- функционалы (используются для построения синтаксически управляемых программ).
\end{itemize}

По назначению функции разделяются следующим образом:
\begin{enumerate}
	\item конструкторы --- создают значение (\texttt{cons}, например);
	\item селекторы --- получают доступ по адресу (\texttt{car}, \texttt{cdr});
	\item предикаты --- возвращают \texttt{Nil}, \texttt{T}.
\end{enumerate}

\subsection*{3. Способы создания функций}

С помощью макро определения \texttt{defun} или с использованием Лямбда-нотации (функция без имени).

\subsection*{Работа функций \texttt{and}, \texttt{or}, \texttt{if}, \texttt{cond}}

\subsubsection*{Функция \texttt{and}}

Синтаксис: \code{(and expression-1 expression-2 ... expression-n)}

Функция возвращает первое \texttt{expression}, результат вычисления которого = \texttt{Nil}. Если все не \texttt{Nil}, то возвращается результат вычисления последнего выражения.

Примеры:
\begin{lstlisting}[label=7xd, language=lisp]
(and 1 Nil 2) -> Nil
(and 1 2 3) -> 3
\end{lstlisting}

\subsubsection*{Функция \texttt{or}}

Синтаксис: \code{(or expression-1 expression-2 ... expression-n)}

Функция возвращает первое \texttt{expression}, результат вычисления которого не \texttt{Nil}. Если все \texttt{Nil}, то возвращается \texttt{Nil}.

Примеры:
\begin{lstlisting}[label=7xd, language=lisp]
(or Nil Nil 2) -> 2
(or 1 2 3) -> 1
\end{lstlisting}

\subsubsection*{Функция \texttt{if}}

Синтаксис: \code{(if condition t-expression f-expression)}

Если вычисленный предикат не \texttt{Nil}, то выполняется \texttt{t-expression}, иначе - \texttt{f-expression}.

Примеры:
\begin{lstlisting}[label=7xd, language=lisp]
(if Nil 2 3) -> 3
(if 0 2 3) -> 2
\end{lstlisting}

\subsubsection*{Функция \texttt{cond}}

Синтаксис:
\begin{lstlisting}[label=7xd, language=lisp]
(cond
  (condition-1 expression-1)
  (condition-2 expression-2)
  ...
  (condition-n expression-n))
\end{lstlisting}

По порядку вычисляются и проверяются на равенство с \texttt{Nil} предикаты. Для первого предиката, который не равен \texttt{Nil}, вычисляется находящееся с ним в списке выражение и возвращается его значение. Если все предикаты вернут \texttt{Nil}, то и \texttt{cond} вернет \texttt{Nil}.

Примеры:
\begin{lstlisting}[label=7xd, language=lisp]
(cond (Nil 1) (2 3)) -> 3
(cond (Nil 1) (Nil 2)) -> Nil
\end{lstlisting}
